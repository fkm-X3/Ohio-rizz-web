#include "engine.hpp"
#include <cstdint>
#include <cstring>


#include <string>

// A simple 5x7 bitmap font for ASCII 32..126
// Each line is a byte, bits 0..4 are pixels.
// We'll define a subset or a procedural generation for simplicity,
// but to be robust let's include a minimal set for the demo text.
// "Hello Browser" "This is rendered in C++ and Rust."

static const uint8_t font5x7[][5] = {
    {0x00, 0x00, 0x00, 0x00, 0x00}, // space
    {0x04, 0x04, 0x04, 0x00, 0x04}, // !
    {0x0A, 0x0A, 0x00, 0x00, 0x00}, // "
    {0x0A, 0x1F, 0x0A, 0x1F, 0x0A}, // #
    {0x0E, 0x15, 0x0E, 0x05, 0x0E}, // $
    {0x18, 0x19, 0x02, 0x13, 0x03}, // %
    {0x0C, 0x12, 0x0D, 0x12, 0x0D}, // &
    {0x04, 0x04, 0x00, 0x00, 0x00}, // '
    {0x02, 0x04, 0x08, 0x04, 0x02}, // (
    {0x08, 0x04, 0x02, 0x04, 0x08}, // )
    {0x00, 0x04, 0x15, 0x0E, 0x15}, // *
    {0x04, 0x04, 0x1F, 0x04, 0x04}, // +
    {0x00, 0x00, 0x00, 0x04, 0x08}, // ,
    {0x00, 0x00, 0x1F, 0x00, 0x00}, // -
    {0x00, 0x00, 0x00, 0x00, 0x04}, // .
    {0x01, 0x02, 0x04, 0x08, 0x10}, // /
    {0x0E, 0x11, 0x11, 0x11, 0x0E}, // 0
    {0x04, 0x0C, 0x04, 0x04, 0x0E}, // 1
    {0x0E, 0x11, 0x02, 0x04, 0x1F}, // 2
    {0x1F, 0x02, 0x0E, 0x01, 0x1F}, // 3
    {0x02, 0x06, 0x0A, 0x1F, 0x02}, // 4
    {0x1F, 0x10, 0x1E, 0x01, 0x1E}, // 5
    {0x06, 0x08, 0x1E, 0x11, 0x0E}, // 6
    {0x1F, 0x01, 0x02, 0x04, 0x04}, // 7
    {0x0E, 0x11, 0x0E, 0x11, 0x0E}, // 8
    {0x0E, 0x11, 0x0F, 0x01, 0x0E}, // 9
    {0x00, 0x04, 0x00, 0x04, 0x00}, // :
    {0x00, 0x04, 0x00, 0x04, 0x08}, // ;
    {0x02, 0x04, 0x08, 0x04, 0x02}, // <
    {0x00, 0x1F, 0x00, 0x1F, 0x00}, // =
    {0x08, 0x04, 0x02, 0x04, 0x08}, // >
    {0x0E, 0x11, 0x02, 0x00, 0x04}, // ?
    {0x0E, 0x11, 0x17, 0x15, 0x0E}, // @
    {0x04, 0x0A, 0x11, 0x1F, 0x11}, // A
    {0x1E, 0x11, 0x1E, 0x11, 0x1E}, // B
    {0x0E, 0x11, 0x10, 0x11, 0x0E}, // C
    {0x1C, 0x12, 0x12, 0x12, 0x1C}, // D
    {0x1F, 0x10, 0x1E, 0x10, 0x1F}, // E
    {0x1F, 0x10, 0x1E, 0x10, 0x10}, // F
    {0x0E, 0x11, 0x10, 0x13, 0x0E}, // G
    {0x11, 0x11, 0x1F, 0x11, 0x11}, // H
    {0x0E, 0x04, 0x04, 0x04, 0x0E}, // I
    {0x01, 0x01, 0x01, 0x11, 0x0E}, // J
    {0x11, 0x12, 0x1C, 0x12, 0x11}, // K
    {0x10, 0x10, 0x10, 0x10, 0x1F}, // L
    {0x11, 0x1B, 0x15, 0x11, 0x11}, // M
    {0x11, 0x19, 0x15, 0x13, 0x11}, // N
    {0x0E, 0x11, 0x11, 0x11, 0x0E}, // O
    {0x1E, 0x11, 0x1E, 0x10, 0x10}, // P
    {0x0E, 0x11, 0x11, 0x12, 0x0D}, // Q
    {0x1E, 0x11, 0x1E, 0x12, 0x11}, // R
    {0x0F, 0x10, 0x0E, 0x01, 0x1E}, // S
    {0x1F, 0x04, 0x04, 0x04, 0x04}, // T
    {0x11, 0x11, 0x11, 0x11, 0x0E}, // U
    {0x11, 0x11, 0x11, 0x0A, 0x04}, // V
    {0x11, 0x11, 0x15, 0x15, 0x0A}, // W
    {0x11, 0x0A, 0x04, 0x0A, 0x11}, // X
    {0x11, 0x0A, 0x04, 0x04, 0x04}, // Y
    {0x1F, 0x02, 0x04, 0x08, 0x1F}, // Z
    {0x0E, 0x08, 0x08, 0x08, 0x0E}, // [
    {0x10, 0x08, 0x04, 0x02, 0x01}, // \ backslash
    {0x0E, 0x02, 0x02, 0x02, 0x0E}, // ]
    {0x04, 0x0A, 0x11, 0x00, 0x00}, // ^
    {0x00, 0x00, 0x00, 0x00, 0x1F}, // _
    {0x04, 0x02, 0x00, 0x00, 0x00}, // `
    {0x00, 0x0E, 0x11, 0x11, 0x0F}, // a
    {0x10, 0x1C, 0x12, 0x12, 0x1C}, // b
    {0x00, 0x0E, 0x10, 0x10, 0x0E}, // c
    {0x01, 0x0E, 0x12, 0x12, 0x0F}, // d
    {0x00, 0x0E, 0x1F, 0x10, 0x0E}, // e
    {0x06, 0x09, 0x1C, 0x08, 0x08}, // f
    {0x00, 0x0D, 0x13, 0x0D, 0x01}, // g
    {0x10, 0x16, 0x19, 0x11, 0x11}, // h
    {0x04, 0x00, 0x0C, 0x04, 0x0E}, // i
    {0x02, 0x00, 0x06, 0x02, 0x0C}, // j
    {0x10, 0x12, 0x14, 0x12, 0x11}, // k
    {0x0C, 0x04, 0x04, 0x04, 0x0E}, // l
    {0x00, 0x1A, 0x15, 0x15, 0x15}, // m
    {0x00, 0x16, 0x19, 0x11, 0x11}, // n
    {0x00, 0x0E, 0x11, 0x11, 0x0E}, // o
    {0x00, 0x1C, 0x12, 0x1C, 0x10}, // p
    {0x00, 0x0D, 0x12, 0x0F, 0x01}, // q
    {0x00, 0x16, 0x19, 0x10, 0x10}, // r
    {0x00, 0x0E, 0x10, 0x08, 0x1E}, // s
    {0x08, 0x1C, 0x08, 0x08, 0x06}, // t
    {0x00, 0x11, 0x11, 0x11, 0x0D}, // u
    {0x00, 0x11, 0x11, 0x0A, 0x04}, // v
    {0x00, 0x11, 0x15, 0x15, 0x0A}, // w
    {0x00, 0x11, 0x0A, 0x0A, 0x11}, // x
    {0x00, 0x11, 0x11, 0x0F, 0x01}, // y
    {0x00, 0x1F, 0x04, 0x08, 0x1F}, // z
    {0x02, 0x04, 0x04, 0x04, 0x02}, // {
    {0x04, 0x04, 0x04, 0x04, 0x04}, // |
    {0x08, 0x04, 0x04, 0x04, 0x08}, // }
    {0x00, 0x00, 0x00, 0x00, 0x00}, // ~ (not impl)
};

static void draw_char(uint32_t *buffer, int buf_w, int buf_h, int x, int y,
                      char c, uint32_t color) {
  if (c < 32 || c > 126)
    return;
  const uint8_t *glyph = font5x7[c - 32];

  // 5x7
  for (int row = 0; row < 5; ++row) {
    int py = y + row;
    if (py < 0 || py >= buf_h)
      continue;

    uint8_t bits = glyph[row];
    // The font data above: e.g. 0x04 = 00000100 -> bit 2 is set, meaning pixel
    // at x+2 wait, usually standard implementation: each byte is a column? OR
    // each byte is a row? Let's assume the data I put above: {0x04, 0x04, 0x04,
    // 0x00, 0x04} for '!' Row 0: 0x04 (..1..) Row 1: 0x04 (..1..)
    // ...
    // So bits correspond to X.
    // Let's iterate bits 0..4 (or 4..0). 0x04 is bit 2.

    for (int col = 0; col < 5; ++col) { // 5 bits wide
      int px = x + col;
      if (px < 0 || px >= buf_w)
        continue;

      // Check bit: (bits >> (4-col)) & 1 usually, or just (bits >> col) & 1
      // depending on endianness of my brain 0x04 = binary 00000100. If we want
      // that to be center, let's say: col 0 = bit 4 col 1 = bit 3 col 2 = bit 2
      // col 3 = bit 1
      // col 4 = bit 0
      if ((bits >> (4 - col)) & 1) {
        buffer[py * buf_w + px] = color;
      }
    }
  }
}

static void draw_string(uint32_t *buffer, int buf_w, int buf_h, int x, int y,
                        const std::string &text, uint32_t color, int scale) {
  int cur_x = x;
  for (char c : text) {
    // Rudimentary scaling
    for (int sy = 0; sy < scale; ++sy) {
      for (int sx = 0; sx < scale; ++sx) {
        // To support scale, draw_char needs to be smarter or we just call it
        // with offset? Actually easier to just bake scale into loop or
        // implementing a scaled_draw_char. For simplicity, let's just do size 1
        // or we modify draw_char to take scale.
      }
    }

    // Simple 1x scale logic for now:
    if (scale == 1) {
      draw_char(buffer, buf_w, buf_h, cur_x, y, c, color);
      cur_x += 6; // 5 width + 1 spacing
    } else {
      // quick hack for scale > 1: just draw pixels as blocks
      if (c < 32 || c > 126)
        continue;
      const uint8_t *glyph = font5x7[c - 32];
      for (int row = 0; row < 5; ++row) {
        for (int col = 0; col < 5; ++col) {
          if ((glyph[row] >> (4 - col)) & 1) {
            // Draw rect of size scale*scale
            for (int dy = 0; dy < scale; ++dy) {
              for (int dx = 0; dx < scale; ++dx) {
                int px = cur_x + col * scale + dx;
                int py = y + row * scale + dy;
                if (px >= 0 && px < buf_w && py >= 0 && py < buf_h) {
                  buffer[py * buf_w + px] = color;
                }
              }
            }
          }
        }
      }
      cur_x += 6 * scale;
    }
  }
}

// Simple extractor
std::string extract_tag_content(const std::string &html,
                                const std::string &tag) {
  std::string start_tag = "<" + tag + ">";
  std::string end_tag = "</" + tag + ">";

  size_t start = html.find(start_tag);
  if (start == std::string::npos)
    return "";
  start += start_tag.length();

  size_t end = html.find(end_tag, start);
  if (end == std::string::npos)
    return "";

  return html.substr(start, end - start);
}

extern "C" {
void render_page(const char *html_cstr, uint32_t *buffer, int width,
                 int height) {
  // Clear background
  for (int i = 0; i < width * height; ++i) {
    buffer[i] = 0xFFFFFFFF; // White
  }

  std::string html(html_cstr);

  // Render H1
  std::string h1_text = extract_tag_content(html, "h1");
  if (!h1_text.empty()) {
    draw_string(buffer, width, height, 20, 20, h1_text, 0xFF000000,
                3); // Black, 3x scale
  }

  // Render P
  std::string p_text = extract_tag_content(html, "p");
  if (!p_text.empty()) {
    draw_string(buffer, width, height, 20, 60, p_text, 0xFF333333,
                1); // Dark gray, 1x scale
  }
}
}
